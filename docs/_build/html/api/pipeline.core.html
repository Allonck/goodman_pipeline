

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>pipeline.core package &mdash; Goodman HTS Pipeline Documentation 1.0.0 documentation</title>
  

  
  
  
  

  

  
  
    

  

  
    <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" /> 

  
  <script src="../_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="../index.html" class="icon icon-home"> Goodman HTS Pipeline Documentation
          

          
          </a>

          
            
            
              <div class="version">
                1.0
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <!-- Local TOC -->
              <div class="local-toc"><ul>
<li><a class="reference internal" href="#">pipeline.core package</a><ul>
<li><a class="reference internal" href="#subpackages">Subpackages</a></li>
<li><a class="reference internal" href="#submodules">Submodules</a></li>
<li><a class="reference internal" href="#module-pipeline.core.core">pipeline.core.core module</a></li>
<li><a class="reference internal" href="#module-pipeline.core">Module contents</a></li>
</ul>
</li>
</ul>
</div>
            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">Goodman HTS Pipeline Documentation</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../index.html">Docs</a> &raquo;</li>
        
      <li>pipeline.core package</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="../_sources/api/pipeline.core.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="pipeline-core-package">
<h1>pipeline.core package<a class="headerlink" href="#pipeline-core-package" title="Permalink to this headline">¶</a></h1>
<div class="section" id="subpackages">
<h2>Subpackages<a class="headerlink" href="#subpackages" title="Permalink to this headline">¶</a></h2>
<div class="toctree-wrapper compound">
<ul>
<li class="toctree-l1"><a class="reference internal" href="pipeline.core.tests.html">pipeline.core.tests package</a><ul>
<li class="toctree-l2"><a class="reference internal" href="pipeline.core.tests.html#submodules">Submodules</a></li>
<li class="toctree-l2"><a class="reference internal" href="pipeline.core.tests.html#module-pipeline.core.tests.test_ccdproc">pipeline.core.tests.test_ccdproc module</a></li>
<li class="toctree-l2"><a class="reference internal" href="pipeline.core.tests.html#module-pipeline.core.tests.test_core">pipeline.core.tests.test_core module</a></li>
<li class="toctree-l2"><a class="reference internal" href="pipeline.core.tests.html#module-pipeline.core.tests">Module contents</a></li>
</ul>
</li>
</ul>
</div>
</div>
<div class="section" id="submodules">
<h2>Submodules<a class="headerlink" href="#submodules" title="Permalink to this headline">¶</a></h2>
</div>
<div class="section" id="module-pipeline.core.core">
<span id="pipeline-core-core-module"></span><h2>pipeline.core.core module<a class="headerlink" href="#module-pipeline.core.core" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="pipeline.core.core.NightDataContainer">
<em class="property">class </em><code class="descclassname">pipeline.core.core.</code><code class="descname">NightDataContainer</code><span class="sig-paren">(</span><em>path</em>, <em>instrument</em>, <em>technique</em><span class="sig-paren">)</span><a class="headerlink" href="#pipeline.core.core.NightDataContainer" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">object</span></code></p>
<p>This class is designed to be the organized data container. It doesn’t
store image data but a list of pandas.DataFrame objects. Also it stores
critical variables such as sunrise and sunset times.</p>
<dl class="method">
<dt id="pipeline.core.core.NightDataContainer.add_bias">
<code class="descname">add_bias</code><span class="sig-paren">(</span><em>bias_group</em><span class="sig-paren">)</span><a class="headerlink" href="#pipeline.core.core.NightDataContainer.add_bias" title="Permalink to this definition">¶</a></dt>
<dd><p>Adds a bias group</p>
<dl class="docutils">
<dt>Args:</dt>
<dd><dl class="first last docutils">
<dt>bias_group (pandas.DataFrame): Contains a set of keyword values of</dt>
<dd>grouped image metadata</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pipeline.core.core.NightDataContainer.add_comp_group">
<code class="descname">add_comp_group</code><span class="sig-paren">(</span><em>comp_group</em><span class="sig-paren">)</span><a class="headerlink" href="#pipeline.core.core.NightDataContainer.add_comp_group" title="Permalink to this definition">¶</a></dt>
<dd><p>Adds a comp-only group</p>
<p>All comparison lamps groups are added here. The ones that may have been
taken in the afternoon (isolated) or along science target. This will
act as a pool of comparison lamp groups for eventual science targets
taken without comparison lamps.</p>
<dl class="docutils">
<dt>Args:</dt>
<dd><dl class="first last docutils">
<dt>comp_group (pandas.DataFrame): Contains a set of keyword values of</dt>
<dd>grouped image metadata</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pipeline.core.core.NightDataContainer.add_data_group">
<code class="descname">add_data_group</code><span class="sig-paren">(</span><em>data_group</em><span class="sig-paren">)</span><a class="headerlink" href="#pipeline.core.core.NightDataContainer.add_data_group" title="Permalink to this definition">¶</a></dt>
<dd><p>Adds a data group</p>
<dl class="docutils">
<dt>Args:</dt>
<dd><dl class="first last docutils">
<dt>data_group (pandas.DataFrame): Contains a set of keyword values of</dt>
<dd>grouped image metadata</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pipeline.core.core.NightDataContainer.add_day_flats">
<code class="descname">add_day_flats</code><span class="sig-paren">(</span><em>day_flats</em><span class="sig-paren">)</span><a class="headerlink" href="#pipeline.core.core.NightDataContainer.add_day_flats" title="Permalink to this definition">¶</a></dt>
<dd><p>“Adds a daytime flat group</p>
<dl class="docutils">
<dt>Args:</dt>
<dd><dl class="first last docutils">
<dt>day_flats (pandas.DataFrame): Contains a set of keyword values of</dt>
<dd>grouped image metadata</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pipeline.core.core.NightDataContainer.add_object_group">
<code class="descname">add_object_group</code><span class="sig-paren">(</span><em>object_group</em><span class="sig-paren">)</span><a class="headerlink" href="#pipeline.core.core.NightDataContainer.add_object_group" title="Permalink to this definition">¶</a></dt>
<dd><p>Adds a object-only group</p>
<dl class="docutils">
<dt>Args:</dt>
<dd><dl class="first last docutils">
<dt>object_group (pandas.DataFrame): Contains a set of keyword values of</dt>
<dd>grouped image metadata</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pipeline.core.core.NightDataContainer.add_spec_group">
<code class="descname">add_spec_group</code><span class="sig-paren">(</span><em>spec_group</em><span class="sig-paren">)</span><a class="headerlink" href="#pipeline.core.core.NightDataContainer.add_spec_group" title="Permalink to this definition">¶</a></dt>
<dd><p>Adds a data group containing object and comp</p>
<p>The comparison lamp groups are also added to a general pool of
comparison lamps.</p>
<dl class="docutils">
<dt>Args:</dt>
<dd><dl class="first last docutils">
<dt>spec_group (pandas.DataFrame): Contains a set of keyword values of</dt>
<dd>grouped image metadata</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="attribute">
<dt id="pipeline.core.core.NightDataContainer.data_groups">
<code class="descname">data_groups</code><em class="property"> = None</em><a class="headerlink" href="#pipeline.core.core.NightDataContainer.data_groups" title="Permalink to this definition">¶</a></dt>
<dd><p>For spectroscopy use</p>
</dd></dl>

<dl class="attribute">
<dt id="pipeline.core.core.NightDataContainer.is_empty">
<code class="descname">is_empty</code><em class="property"> = None</em><a class="headerlink" href="#pipeline.core.core.NightDataContainer.is_empty" title="Permalink to this definition">¶</a></dt>
<dd><p>For imaging use</p>
</dd></dl>

<dl class="method">
<dt id="pipeline.core.core.NightDataContainer.set_readout">
<code class="descname">set_readout</code><span class="sig-paren">(</span><em>gain</em>, <em>rdnoise</em>, <em>roi</em><span class="sig-paren">)</span><a class="headerlink" href="#pipeline.core.core.NightDataContainer.set_readout" title="Permalink to this definition">¶</a></dt>
<dd><p>Set Gain, Read noise and ROI.</p>
<dl class="docutils">
<dt>Args:</dt>
<dd>gain (float): Gain from header
rdnoise (float): Read noise from header.
roi (str): ROI from header.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pipeline.core.core.NightDataContainer.set_sun_times">
<code class="descname">set_sun_times</code><span class="sig-paren">(</span><em>sun_set</em>, <em>sun_rise</em><span class="sig-paren">)</span><a class="headerlink" href="#pipeline.core.core.NightDataContainer.set_sun_times" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets values for sunset and sunrise</p>
<dl class="docutils">
<dt>Args:</dt>
<dd>sun_set (str): Sun set time in the format ‘YYYY-MM-DDTHH:MM:SS.SS’
sun_rise (str):Sun rise time in the format ‘YYYY-MM-DDTHH:MM:SS.SS’</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pipeline.core.core.NightDataContainer.set_twilight_times">
<code class="descname">set_twilight_times</code><span class="sig-paren">(</span><em>evening</em>, <em>morning</em><span class="sig-paren">)</span><a class="headerlink" href="#pipeline.core.core.NightDataContainer.set_twilight_times" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets values for evening and morning twilight</p>
<dl class="docutils">
<dt>Args:</dt>
<dd><dl class="first last docutils">
<dt>evening (str): Evening twilight time in the format</dt>
<dd>‘YYYY-MM-DDTHH:MM:SS.SS’</dd>
<dt>morning (str): Morning twilight time in the format</dt>
<dd>‘YYYY-MM-DDTHH:MM:SS.SS’</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="attribute">
<dt id="pipeline.core.core.NightDataContainer.spec_groups">
<code class="descname">spec_groups</code><em class="property"> = None</em><a class="headerlink" href="#pipeline.core.core.NightDataContainer.spec_groups" title="Permalink to this definition">¶</a></dt>
<dd><p>Time reference points</p>
</dd></dl>

</dd></dl>

<dl class="exception">
<dt id="pipeline.core.core.NoMatchFound">
<em class="property">exception </em><code class="descclassname">pipeline.core.core.</code><code class="descname">NoMatchFound</code><a class="headerlink" href="#pipeline.core.core.NoMatchFound" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">Exception</span></code></p>
<p>Exception for when no match is found.</p>
</dd></dl>

<dl class="exception">
<dt id="pipeline.core.core.NoTargetException">
<em class="property">exception </em><code class="descclassname">pipeline.core.core.</code><code class="descname">NoTargetException</code><a class="headerlink" href="#pipeline.core.core.NoTargetException" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">Exception</span></code></p>
<p>Exception to be raised when no target is identified</p>
</dd></dl>

<dl class="exception">
<dt id="pipeline.core.core.NotEnoughLinesDetected">
<em class="property">exception </em><code class="descclassname">pipeline.core.core.</code><code class="descname">NotEnoughLinesDetected</code><a class="headerlink" href="#pipeline.core.core.NotEnoughLinesDetected" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">Exception</span></code></p>
<p>Exception for when there are no lines detected.</p>
</dd></dl>

<dl class="class">
<dt id="pipeline.core.core.ReferenceData">
<em class="property">class </em><code class="descclassname">pipeline.core.core.</code><code class="descname">ReferenceData</code><span class="sig-paren">(</span><em>reference_dir</em><span class="sig-paren">)</span><a class="headerlink" href="#pipeline.core.core.ReferenceData" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">object</span></code></p>
<p>Contains spectroscopic reference lines values and filename to templates.</p>
<dl class="docutils">
<dt>This class stores:</dt>
<dd><ul class="first last simple">
<li>file names for reference fits spectrum</li>
<li>file names for CSV tables with reference lines and relative
intensities</li>
<li>line positions only for the elements used in SOAR comparison lamps</li>
</ul>
</dd>
</dl>
<dl class="method">
<dt id="pipeline.core.core.ReferenceData.check_comp_group">
<code class="descname">check_comp_group</code><span class="sig-paren">(</span><em>comp_group</em><span class="sig-paren">)</span><a class="headerlink" href="#pipeline.core.core.ReferenceData.check_comp_group" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if comparison lamp group has matching reference lamps</p>
<dl class="docutils">
<dt>Args:</dt>
<dd><dl class="first last docutils">
<dt>comp_group (object): <cite>pandas.DataFrame</cite> instance that contains</dt>
<dd>meta-data for a group of comparison lamps.</dd>
</dl>
</dd>
</dl>
<p>Returns:</p>
</dd></dl>

<dl class="method">
<dt id="pipeline.core.core.ReferenceData.get_reference_lamp">
<code class="descname">get_reference_lamp</code><span class="sig-paren">(</span><em>header</em><span class="sig-paren">)</span><a class="headerlink" href="#pipeline.core.core.ReferenceData.get_reference_lamp" title="Permalink to this definition">¶</a></dt>
<dd><p>Finds a suitable template lamp from the catalog</p>
<dl class="docutils">
<dt>Args:</dt>
<dd><dl class="first last docutils">
<dt>header (object): FITS header of image we are looking a a reference</dt>
<dd>lamp.</dd>
</dl>
</dd>
<dt>Returns:</dt>
<dd>full path to best matching reference lamp.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pipeline.core.core.ReferenceData.lamp_exists">
<code class="descname">lamp_exists</code><span class="sig-paren">(</span><em>object_name</em>, <em>grating</em>, <em>grt_targ</em>, <em>cam_targ</em><span class="sig-paren">)</span><a class="headerlink" href="#pipeline.core.core.ReferenceData.lamp_exists" title="Permalink to this definition">¶</a></dt>
<dd><p>Checks whether a matching lamp exist or not</p>
<dl class="docutils">
<dt>Args:</dt>
<dd>object_name (str): Name of the lamp from ‘OBJECT’ keyword.
grating (str): Grating from ‘GRATING’ keyword.
grt_targ (str): Grating target from keyword ‘GRT_TARG’.
cam_targ (str): Camera target from keyword ‘CAM_TARG’.</dd>
<dt>Returns:</dt>
<dd>True of False depending if a single matching lamp exist.</dd>
<dt>Raises:</dt>
<dd>NotImplementedError if there are more than one lamp found.</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="pipeline.core.core.SpectroscopicMode">
<em class="property">class </em><code class="descclassname">pipeline.core.core.</code><code class="descname">SpectroscopicMode</code><a class="headerlink" href="#pipeline.core.core.SpectroscopicMode" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">object</span></code></p>
<dl class="method">
<dt id="pipeline.core.core.SpectroscopicMode.get_cam_grt_targ_angle">
<code class="descname">get_cam_grt_targ_angle</code><span class="sig-paren">(</span><em>grating</em>, <em>mode</em><span class="sig-paren">)</span><a class="headerlink" href="#pipeline.core.core.SpectroscopicMode.get_cam_grt_targ_angle" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the camera and grating target values grating and mode</p>
<dl class="docutils">
<dt>Args:</dt>
<dd>grating (float): Grating frequency in lines/mm (unitless value)
mode (str): Name of the grating’s mode for which the camera and
grating target values are required.</dd>
<dt>Returns:</dt>
<dd>Camera and grating target values. None and None if no such values
exists.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pipeline.core.core.SpectroscopicMode.get_mode">
<code class="descname">get_mode</code><span class="sig-paren">(</span><em>grating</em>, <em>camera_targ</em>, <em>grating_targ</em>, <em>blocking_filter</em><span class="sig-paren">)</span><a class="headerlink" href="#pipeline.core.core.SpectroscopicMode.get_mode" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the camera’s optical configuration mode.</p>
<p>This method is useful for data that does not have the WAVMODE keyword</p>
<dl class="docutils">
<dt>Args:</dt>
<dd>grating (str): Grating frequency as string
camera_targ (str): Camera target angle as in the header.
grating_targ (str): Grating target angle as in the header.
blocking_filter (str): Order blocking filter listed on the header.</dd>
<dt>Returns:</dt>
<dd>string that defines the wavelength mode used</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="function">
<dt id="pipeline.core.core.add_wcs_keys">
<code class="descclassname">pipeline.core.core.</code><code class="descname">add_wcs_keys</code><span class="sig-paren">(</span><em>ccd</em><span class="sig-paren">)</span><a class="headerlink" href="#pipeline.core.core.add_wcs_keys" title="Permalink to this definition">¶</a></dt>
<dd><p>Adds generic keyword for linear wavelength solution to the header</p>
<p>Linear wavelength solutions require a set of standard fits keywords. Later
on they will be updated accordingly.
The main goal of putting them here is to have consistent and nicely ordered
headers.</p>
<dl class="docutils">
<dt>Notes:</dt>
<dd>This does NOT add a WCS solution, just the keywords.</dd>
<dt>Args:</dt>
<dd>ccd (object): ccdproc.CCDData instance with no wcs keywords.</dd>
<dt>Returns:</dt>
<dd><dl class="first last docutils">
<dt>ccd (object): ccdproc.CCDData instance with modified header with added</dt>
<dd>WCS keywords</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="pipeline.core.core.call_cosmic_rejection">
<code class="descclassname">pipeline.core.core.</code><code class="descname">call_cosmic_rejection</code><span class="sig-paren">(</span><em>ccd</em>, <em>image_name</em>, <em>out_prefix</em>, <em>red_path</em>, <em>dcr_par</em>, <em>keep_files=False</em>, <em>prefix='c'</em>, <em>method='dcr'</em>, <em>save=False</em><span class="sig-paren">)</span><a class="headerlink" href="#pipeline.core.core.call_cosmic_rejection" title="Permalink to this definition">¶</a></dt>
<dd><p>Call for the appropriate cosmic ray rejection method</p>
<p>There are three options when dealing with cosmic ray rejection in this
pipeline, the first is <code class="docutils literal"><span class="pre">dcr</span></code> which is a program written in C by Wojtek
Pych (<a class="reference external" href="http://users.camk.edu.pl/pych/DCR/">http://users.camk.edu.pl/pych/DCR/</a>) that works very well for
spectroscopy the only negative aspect is that integration with python was
difficult and not natively (through subprocess). The second option is
<cite>lacosmic</cite> or <cite>ccdproc.cosmicray_lacosmic</cite>
(<a class="reference external" href="http://www.astro.yale.edu/dokkum/lacosmic/">http://www.astro.yale.edu/dokkum/lacosmic/</a>) by Pieter G. van Dokkum. The
negative aspect is that it does not work well with spectroscopic data and it
does not apply the correction to the images instead it updates the mask
attribute. And the third is not doing any correction.</p>
<dl class="docutils">
<dt>Args:</dt>
<dd>ccd (object): a ccdproc.CCDData instance.
image_name (str): Science image name.
out_prefix (str): Partial prefix to be added to the image name. Related
to previous processes and not cosmic ray rejection.
red_path (str): Path to reduced data directory.
dcr_par (str): Path to dcr.par file.
keep_files (bool): If True, the original file and the cosmic ray mask
will not be deleted. Default is False.
prefix (str): Cosmic ray rejection related prefix to be added to image
name.
method (str): Method to use for cosmic ray rejection. There are three
options: <cite>dcr</cite>, <cite>lacosmic</cite> and <cite>none</cite>.
save (bool): Disables by default saving the images</dd>
<dt>Returns:</dt>
<dd>ccdproc.CCDData instance and <cite>out_prefix</cite> which is the prefix added to
the image name.</dd>
<dt>Raises:</dt>
<dd>NotImplementedError if the <cite>method</cite> argument is not <cite>dcr</cite>, <cite>lacosmic</cite>
nor <cite>none</cite>.</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="pipeline.core.core.classify_spectroscopic_data">
<code class="descclassname">pipeline.core.core.</code><code class="descname">classify_spectroscopic_data</code><span class="sig-paren">(</span><em>path</em>, <em>search_pattern</em><span class="sig-paren">)</span><a class="headerlink" href="#pipeline.core.core.classify_spectroscopic_data" title="Permalink to this definition">¶</a></dt>
<dd><p>Classify data by grouping them by a set of keywords.</p>
<p>This functions uses ImageFileCollection from ccdproc. First it creates a
collection of information regarding the images located in <em>path</em> that match
the pattern <em>search_pattern</em>
The information obtained are all keywords listed in the list <em>keywords</em>
The ImageFileCollection is translated into pandas.DataFrame and then is used
much like an SQL database to select and filter values and in that way put
them in groups that are pandas.DataFrame instances.</p>
<p>The keywords retrieved are: ‘date’, ‘slit’, ‘date-obs’, ‘obstype’, ‘object’,
‘exptime’, ‘obsra’, ‘obsdec’, ‘grating’, ‘cam_targ’, ‘grt_targ’, ‘filter’,
‘filter2’, ‘gain’ and ‘rdnoise’. Then all data is grouped by matching the
following keywords: ‘slit’, ‘radeg’, ‘decdeg’, ‘grating’, ‘cam_targ’,
‘grt_targ’, ‘filter’, ‘filter2’, ‘gain’ and ‘rdnoise’ and finally every
group is classified as: a comparison lamp-only group, an object-only group
or a group of object and comparison lamps. The comparison lamps present in
the last group (COMP + OBJECT) are also added in the first one (COMP-only).</p>
<dl class="docutils">
<dt>Args:</dt>
<dd>path (str): Path to data location
search_pattern (str): Prefix to match files.</dd>
<dt>Returns:</dt>
<dd><dl class="first last docutils">
<dt>data_container (object): Instance of</dt>
<dd><cite>goodman.pipeline.core.NightDataContainer</cite></dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="pipeline.core.core.combine_data">
<code class="descclassname">pipeline.core.core.</code><code class="descname">combine_data</code><span class="sig-paren">(</span><em>image_list</em>, <em>dest_path</em>, <em>prefix=None</em>, <em>output_name=None</em>, <em>method='median'</em>, <em>save=False</em><span class="sig-paren">)</span><a class="headerlink" href="#pipeline.core.core.combine_data" title="Permalink to this definition">¶</a></dt>
<dd><p>Combine a list of CCDData instances.</p>
<dl class="docutils">
<dt>Args:</dt>
<dd>image_list (list): Each element should be an instance of ccdproc.CCDData
dest_path (str): Path to where the new image should saved
prefix (str): Prefix to add to the image file name
output_name (str): Alternatively a file name can be parsed, this will
ignore <cite>prefix</cite>.
method (str): Method for doing the combination, this goes straight to
the call of <cite>ccdproc.combine</cite> function.
save (bool): If True will save the combined images. If False it will
ignore <cite>prefix</cite> or <cite>output_name</cite>.</dd>
<dt>Returns:</dt>
<dd>A combined image as a CCDData object.</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="pipeline.core.core.convert_time">
<code class="descclassname">pipeline.core.core.</code><code class="descname">convert_time</code><span class="sig-paren">(</span><em>in_time</em><span class="sig-paren">)</span><a class="headerlink" href="#pipeline.core.core.convert_time" title="Permalink to this definition">¶</a></dt>
<dd><p>Converts time to seconds since epoch</p>
<dl class="docutils">
<dt>Args:</dt>
<dd>in_time (str): time obtained from header’s keyword DATE-OBS</dd>
<dt>Returns:</dt>
<dd>time in seconds since epoch</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="pipeline.core.core.dcr_cosmicray_rejection">
<code class="descclassname">pipeline.core.core.</code><code class="descname">dcr_cosmicray_rejection</code><span class="sig-paren">(</span><em>data_path</em>, <em>in_file</em>, <em>prefix</em>, <em>dcr_par_dir</em>, <em>delete=False</em>, <em>save=True</em><span class="sig-paren">)</span><a class="headerlink" href="#pipeline.core.core.dcr_cosmicray_rejection" title="Permalink to this definition">¶</a></dt>
<dd><p>Runs an external code for cosmic ray rejection</p>
<p>DCR was created by Wojtek Pych and the code can be obtained from
<a class="reference external" href="http://users.camk.edu.pl/pych/DCR/">http://users.camk.edu.pl/pych/DCR/</a> and is written in C. Contrary to
ccdproc’s LACosmic it actually applies the correction, and also doesn’t
update the mask attribute since it doesn’t work with CCDData instances.</p>
<p>The binary takes three positional arguments, they are: 1. input image,
2. output image and 3. cosmic rays image. Also it needs that a dcr.par file
is located in the directory. All this is implemented in this function, if
<cite>delete</cite> is True it will remove the original image and the cosmic rays
image. The removal of the original image is absolutely safe when used in the
context of the goodman pipeline, however if you want to implement it
somewhere else, be careful.</p>
<dl class="docutils">
<dt>Notes:</dt>
<dd>This function operates an external code therefore it doesn’t return
anything natively, instead it creates a new image. A workaround has been
created that loads the new image and deletes the file.</dd>
<dt>Args:</dt>
<dd>data_path (str): Data location
in_file (str): Name of the file to have its cosmic rays removed
prefix (str): Prefix to add to the file with the cosmic rays removed
dcr_par_dir (str): Directory of default dcr.par file
delete (bool): True for deleting the input and cosmic ray file.
save (bool): Toggles the option of saving the image.</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="pipeline.core.core.extract_fractional_pixel">
<code class="descclassname">pipeline.core.core.</code><code class="descname">extract_fractional_pixel</code><span class="sig-paren">(</span><em>ccd</em>, <em>target_trace</em>, <em>target_stddev</em>, <em>extraction_width</em>, <em>background_spacing=3</em><span class="sig-paren">)</span><a class="headerlink" href="#pipeline.core.core.extract_fractional_pixel" title="Permalink to this definition">¶</a></dt>
<dd><p>Performs an spectrum extraction using fractional pixels.</p>
<dl class="docutils">
<dt>Args:</dt>
<dd>ccd (object): Instance of ccdproc.CCDData that contains a 2D spectrum.
target_trace (object):  Instance of astropy.modeling.models.Model that
defines the trace of the target on the image (ccd).
target_stddev (float): Standard deviation value for the spatial profile
fitted to the target.
extraction_width (int): Width of the extraction area as a function of
<cite>target_stddev</cite>. For instance if <cite>extraction_with</cite> is set to 1 the
function extract 0.5 to each side from the center of the traced
target.
background_spacing (float): Number of <cite>target_stddev</cite> to separate the
target extraction to the background. This is from the edge of the
extraction zone to the edge of the background region.</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="pipeline.core.core.extract_optimal">
<code class="descclassname">pipeline.core.core.</code><code class="descname">extract_optimal</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pipeline.core.core.extract_optimal" title="Permalink to this definition">¶</a></dt>
<dd><p>Placeholder for optimal extraction method.</p>
<dl class="docutils">
<dt>Raises:</dt>
<dd>NotImplementedError</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="pipeline.core.core.extraction">
<code class="descclassname">pipeline.core.core.</code><code class="descname">extraction</code><span class="sig-paren">(</span><em>ccd</em>, <em>target_trace</em>, <em>spatial_profile</em>, <em>extraction_name</em><span class="sig-paren">)</span><a class="headerlink" href="#pipeline.core.core.extraction" title="Permalink to this definition">¶</a></dt>
<dd><p>Calls appropriate spectrum extraction routine</p>
<p>This function calls the appropriate extraction function based on
<cite>extraction_name</cite></p>
<dl class="docutils">
<dt>Notes:</dt>
<dd>Optimal extraction is not implemented.</dd>
<dt>Args:</dt>
<dd>ccd (object): Instance of ccdproc.CCDData containing a 2D spectrum
target_trace (object): Instance of astropy.modeling.Model, a low order
polynomial that defines the trace of the spectrum in the ccd object.
spatial_profile (object): Instance of astropy.modeling.Model, a Gaussian
model previously fitted to the spatial profile of the 2D spectrum
contained in the ccd object.
extraction_name (str): Extraction type, can be <cite>fractional</cite> or
<cite>optimal</cite> though the optimal extraction is not implemented yet.</dd>
<dt>Returns:</dt>
<dd>ccd (object): Instance of ccdproc.CCDData containing a 1D spectrum. The
attribute ‘data’ is replaced by the 1D array resulted from the
extraction process.</dd>
<dt>Raises:</dt>
<dd>NotImplementedError: When <cite>extraction_name</cite> is <cite>optimal</cite>.</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="pipeline.core.core.fractional_sum">
<code class="descclassname">pipeline.core.core.</code><code class="descname">fractional_sum</code><span class="sig-paren">(</span><em>data</em>, <em>index</em>, <em>low_limit</em>, <em>high_limit</em><span class="sig-paren">)</span><a class="headerlink" href="#pipeline.core.core.fractional_sum" title="Permalink to this definition">¶</a></dt>
<dd><p>Performs a fractional pixels sum</p>
<p>A fractional pixels sum is required several times while
extracting a 1D spectrum from a 2D spectrum. The method
is actually very simple.</p>
<p>It requires the full data, the column and the range to sum, this
range is given as real numbers. First it separates the limits values as an
integer and fractional parts. Then it will sum the integer’s interval and
subtract the <cite>low_limit</cite>’s fractional part and sum the <cite>high_limit</cite>’s
fractional part.</p>
<p>The sum is performed in one operation. It does not do
background subtraction, for which this very same method is used to
get the background sum to be subtracted later.</p>
<dl class="docutils">
<dt>Args:</dt>
<dd>data (numpy.ndarray): 2D array that contains the 2D spectrum/image
index (int): Index of the column to be summed.
low_limit (float): Lower limit for the range to be summed.
high_limit (float): Higher limit for the range to be summed.</dd>
<dt>Returns:</dt>
<dd>Sum in ADU of all pixels and fractions between <cite>low_limit</cite> and
<cite>high_limit</cite>.</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="pipeline.core.core.get_best_flat">
<code class="descclassname">pipeline.core.core.</code><code class="descname">get_best_flat</code><span class="sig-paren">(</span><em>flat_name</em>, <em>path</em><span class="sig-paren">)</span><a class="headerlink" href="#pipeline.core.core.get_best_flat" title="Permalink to this definition">¶</a></dt>
<dd><p>Look for matching master flat</p>
<p>Given a basename for master flats defined as a combination of key parameters
extracted from the header of the image that we want to flat field, this
function will find the name of the files that matches the base name and then
will choose the first. Ideally this should go further as to check signal,
time gap, etc.
After it identifies the file it will load it using ccdproc.CCDData and
return it along the filename.
In the case it fails it will return None instead of master_flat and another
None instead of master_flat_name.</p>
<dl class="docutils">
<dt>Args:</dt>
<dd>flat_name (str): Full path of master flat basename. Ends in ‘*.fits’ for
using glob.
path (str): Location to look for flats.</dd>
<dt>Returns:</dt>
<dd>master_flat (object): A ccdproc.CCDData instance.
master_flat_name (str): Full path to the chosen master flat.</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="pipeline.core.core.get_central_wavelength">
<code class="descclassname">pipeline.core.core.</code><code class="descname">get_central_wavelength</code><span class="sig-paren">(</span><em>grating</em>, <em>grt_ang</em>, <em>cam_ang</em><span class="sig-paren">)</span><a class="headerlink" href="#pipeline.core.core.get_central_wavelength" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates the central wavelength for a given spectroscopic mode</p>
<p>The equation used to calculate the central wavelength is the following</p>
<dl class="docutils">
<dt>Args:</dt>
<dd>grating (str): Grating frequency as a string. Example ‘400’.
grt_ang (str): Grating Angle as a string. Example ‘12.0’.
cam_ang (str): Camera Angle as a string. Example ‘20.0’</dd>
<dt>Returns:</dt>
<dd>central_wavelength (float): Central wavelength as a float value.</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="pipeline.core.core.get_slit_trim_section">
<code class="descclassname">pipeline.core.core.</code><code class="descname">get_slit_trim_section</code><span class="sig-paren">(</span><em>master_flat</em><span class="sig-paren">)</span><a class="headerlink" href="#pipeline.core.core.get_slit_trim_section" title="Permalink to this definition">¶</a></dt>
<dd><p>Find the slit edges to trim all data</p>
<p>Using a master flat, ideally with good signal to noise ratio, this function
will identify the edges of the slit projected into the detector. Having this
done will allow to reduce the overall processing time and also reduce the
introduction of artifacts due to non-illuminated regions in the detectors,
such as NaNs -INF +INF, etc.</p>
<dl class="docutils">
<dt>Args:</dt>
<dd>master_flat (object): A ccdproc.CCDData instance.</dd>
<dt>Returns:</dt>
<dd><dl class="first last docutils">
<dt>slit_trim_section (str): Trim section in spatial direction in the format</dt>
<dd>[:,slit_lower_limit:slit_higher_limit]</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="pipeline.core.core.get_twilight_time">
<code class="descclassname">pipeline.core.core.</code><code class="descname">get_twilight_time</code><span class="sig-paren">(</span><em>date_obs</em><span class="sig-paren">)</span><a class="headerlink" href="#pipeline.core.core.get_twilight_time" title="Permalink to this definition">¶</a></dt>
<dd><p>Get end/start time of evening/morning twilight</p>
<dl class="docutils">
<dt>Notes:</dt>
<dd>Taken from David Sanmartim’s development</dd>
<dt>Args:</dt>
<dd>date_obs (list): List of all the dates from data.</dd>
<dt>Returns:</dt>
<dd><dl class="first last docutils">
<dt>twilight_evening (str): Evening twilight time in the format</dt>
<dd>‘YYYY-MM-DDTHH:MM:SS.SS’</dd>
<dt>twilight_morning (str): Morning twilight time in the format</dt>
<dd>‘YYYY-MM-DDTHH:MM:SS.SS’</dd>
<dt>sun_set_time (str): Sun set time in the format</dt>
<dd>‘YYYY-MM-DDTHH:MM:SS.SS’</dd>
<dt>sun_rise_time (str): Sun rise time in the format</dt>
<dd>‘YYYY-MM-DDTHH:MM:SS.SS’</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="pipeline.core.core.identify_targets">
<code class="descclassname">pipeline.core.core.</code><code class="descname">identify_targets</code><span class="sig-paren">(</span><em>ccd</em>, <em>nfind=3</em>, <em>plots=False</em><span class="sig-paren">)</span><a class="headerlink" href="#pipeline.core.core.identify_targets" title="Permalink to this definition">¶</a></dt>
<dd><p>Identify spectroscopic targets in an image</p>
<p>This function collapses the image along the dispersion direction using a
median, This highlights the spatial features present in a 2D spectrum
(image), Then does a sigma clip to remove any features in order to fit the
background level and shape, the fit is a linear function. Once the
background has been removed it will equal to zero all negative values. It
will perform a new sigma clipping but this time to determinate the
background amplitude. Finally it finds all the peaks above the background
level and pick the <cite>nfind</cite> largest ones.</p>
<dl class="docutils">
<dt>Args:</dt>
<dd>ccd (object): a ccdproc.CCDData instance.
nfind (int): Maximum number of targets to be returned.
plots (bool): To show debugging plots.</dd>
<dt>Returns:</dt>
<dd><dl class="first last docutils">
<dt>profile_model (object): an astropy.modeling.Model instance, it could be</dt>
<dd>a Gaussian1D or a list of  Gaussian1D. Each of them represent a
point source spectrum found. In the past a <cite>CompoundModel</cite> was
returned but the processing of those was slightly more complicated
than a list of Gaussian1Ds.</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="pipeline.core.core.image_overscan">
<code class="descclassname">pipeline.core.core.</code><code class="descname">image_overscan</code><span class="sig-paren">(</span><em>ccd</em>, <em>overscan_region</em>, <em>add_keyword=False</em><span class="sig-paren">)</span><a class="headerlink" href="#pipeline.core.core.image_overscan" title="Permalink to this definition">¶</a></dt>
<dd><p>Apply overscan correction to data</p>
<p>Uses ccdproc.subtract_overscan to perform the task.</p>
<dl class="docutils">
<dt>Notes:</dt>
<dd>The overscan_region argument uses FITS convention, just like IRAF,
therefore is 1 based. i.e. it starts in 1 not 0.</dd>
<dt>Args:</dt>
<dd>ccd (object): A ccdproc.CCDData instance to be overscan corrected.
overscan_region (str): The overscan region in the format <cite>[x1:x2,y1:y2]</cite>
where x is the spectral axis and y is the spatial axis.
add_keyword (bool): Tells ccdproc whether to add a keyword or not.
Default False.</dd>
<dt>Returns:</dt>
<dd>ccd (object): Overscan corrected ccdproc.CCDData instance</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="pipeline.core.core.image_trim">
<code class="descclassname">pipeline.core.core.</code><code class="descname">image_trim</code><span class="sig-paren">(</span><em>ccd</em>, <em>trim_section</em>, <em>trim_type='trimsec'</em>, <em>add_keyword=False</em><span class="sig-paren">)</span><a class="headerlink" href="#pipeline.core.core.image_trim" title="Permalink to this definition">¶</a></dt>
<dd><p>Trim image to a given section</p>
<dl class="docutils">
<dt>Notes:</dt>
<dd>The overscan_region argument uses FITS convention, just like IRAF,
therefore is 1 based. i.e. it starts in 1 not 0.</dd>
<dt>Args:</dt>
<dd>ccd (object): A ccdproc.CCDData instance.
trim_section (str): The trimming section in the format <cite>[x1:x2,y1:y2]</cite>
where x is the spectral axis and y is the spatial axis.
trim_type (str): trimsec or slit trim.
add_keyword (bool): Tells ccdproc whether to add a keyword or not.
Default False.</dd>
<dt>Returns:</dt>
<dd>ccd (object): Trimmed ccdproc.CCDData instance</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="pipeline.core.core.interpolate">
<code class="descclassname">pipeline.core.core.</code><code class="descname">interpolate</code><span class="sig-paren">(</span><em>spectrum</em>, <em>interpolation_size</em><span class="sig-paren">)</span><a class="headerlink" href="#pipeline.core.core.interpolate" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates an interpolated version of the input spectrum</p>
<p>This method creates an interpolated version of the input array, it is
used mainly for a spectrum but it can also be used with any
unidimensional array. The reason for doing interpolation is
that it allows to find the lines and its respective center more
precisely.</p>
<dl class="docutils">
<dt>Args:</dt>
<dd><dl class="first last docutils">
<dt>spectrum (array): an uncalibrated spectrum or any unidimensional</dt>
<dd>array.</dd>
<dt>interpolation_size (int): Number of points to interpolate. (points added</dt>
<dd>between two existing ones)</dd>
</dl>
</dd>
<dt>Returns:</dt>
<dd><dl class="first last docutils">
<dt>Two dimensional array containing x-axis and interpolated array.</dt>
<dd>The x-axis preserves original pixel values.</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="pipeline.core.core.lacosmic_cosmicray_rejection">
<code class="descclassname">pipeline.core.core.</code><code class="descname">lacosmic_cosmicray_rejection</code><span class="sig-paren">(</span><em>ccd</em>, <em>mask_only=False</em><span class="sig-paren">)</span><a class="headerlink" href="#pipeline.core.core.lacosmic_cosmicray_rejection" title="Permalink to this definition">¶</a></dt>
<dd><p>Do cosmic ray rejection using <cite>ccdproc.cosmicray_lacosmic</cite></p>
<p>This function in fact does not apply any correction, it detects the cosmic
rays and updates the attribute mask of the ccd object (CCDData instance).
The attribute mask is used later as a mask for the pixels hit by cosmic rays</p>
<dl class="docutils">
<dt>Notes:</dt>
<dd>OBS: cosmic ray rejection is working pretty well by defining gain = 1.
It’s not working when we use the real gain of the image. In this case
the sky level changes by a factor equal to the gain.
Function to determine the <cite>sigfrac</cite> and <cite>objlim</cite>:</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="pipeline.core.core.normalize_master_flat">
<code class="descclassname">pipeline.core.core.</code><code class="descname">normalize_master_flat</code><span class="sig-paren">(</span><em>master</em>, <em>name</em>, <em>method='simple'</em>, <em>order=15</em><span class="sig-paren">)</span><a class="headerlink" href="#pipeline.core.core.normalize_master_flat" title="Permalink to this definition">¶</a></dt>
<dd><p>Master flat normalization method</p>
<dl class="docutils">
<dt>This function normalize a master flat in three possible ways:</dt>
<dd><p class="first"><em>mean</em>: simply divide the data by its mean</p>
<p><em>simple</em>: Calculates the median along the spatial axis in order to obtain
the dispersion profile. Then fits a Chebyshev1D model and apply this to all
the data.</p>
<p class="last"><em>full</em>: This is for experimental purposes only because it takes a lot of
time to process. It will fit a model to each line along the dispersion axis
and then divide it by the fitted model. I do not recommend this method
unless you have a good reason as well as a very powerful computer.</p>
</dd>
<dt>Args:</dt>
<dd>master (object): Master flat. Has to be a ccdproc.CCDData instance.
name (str): Full path of master flat prior to normalization.
method (str): Normalization method, ‘mean’, ‘simple’ or ‘full’.
order (int): Order of the polynomial to be fitted.</dd>
<dt>Returns:</dt>
<dd>master (object):  The normalized master flat. ccdproc.CCDData instance.</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="pipeline.core.core.ra_dec_to_deg">
<code class="descclassname">pipeline.core.core.</code><code class="descname">ra_dec_to_deg</code><span class="sig-paren">(</span><em>right_ascension</em>, <em>declination</em><span class="sig-paren">)</span><a class="headerlink" href="#pipeline.core.core.ra_dec_to_deg" title="Permalink to this definition">¶</a></dt>
<dd><p>Converts right ascension and declination to degrees</p>
<dl class="docutils">
<dt>Args:</dt>
<dd>right_ascension (str): Right ascension in the format hh:mm:ss.sss
declination (str): Declination in the format dd:mm:ss.sss</dd>
<dt>Returns:</dt>
<dd>right_ascension_deg (float): Right ascension in degrees
declination_deg (float): Declination in degrees</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="pipeline.core.core.read_fits">
<code class="descclassname">pipeline.core.core.</code><code class="descname">read_fits</code><span class="sig-paren">(</span><em>full_path</em>, <em>technique='Unknown'</em><span class="sig-paren">)</span><a class="headerlink" href="#pipeline.core.core.read_fits" title="Permalink to this definition">¶</a></dt>
<dd><p>Read fits files while adding important information to the header</p>
<p>It is necessary to record certain data to the image header so that’s the
reason for this wrapper of <cite>ccdproc.CCDData.read()</cite> to exist. It will add
the following keywords. In most cases, if the keyword already exist it will
skip it except for <cite>GSP_FNAM</cite>, <cite>GSP_PATH</cite> and <cite>BUNIT</cite>.
GSP_VERS: Goodman Spectroscopic Pipeline version number
GSP_ONAM: Original File name
GSP_PNAM: Parent file name or name of the file from which this one
originated after some process or just a copy.
GSP_FNAM: Current file name.
GSP_PATH: Path to file at the moment of reading.
GSP_TECH: Observing technique. <cite>Spectroscopy</cite> or <cite>Imaging</cite>.
GSP_DATE: Date of first reading.
GSP_OVER: Overscan region.
GSP_TRIM: Trim section (region).
GSP_SLIT: Slit trim section, obtained from the slit illuminated area.
GSP_BIAS: Master bias image used. Default <cite>none</cite>.
GSP_FLAT: Master flat image used. Default <cite>none</cite>.
GSP_NORM: Flat normalization method.
GSP_COSM: Cosmic ray rejection method.
GSP_WRMS: Wavelength solution RMS Error.
GSP_WPOI: Number of points used to calculate the wavelength solution
Error.
GSP_WREJ: Number of points rejected.</p>
<dl class="docutils">
<dt>Args:</dt>
<dd>full_path (str): Full path to file.
technique (str): Observing technique. ‘Imaging’ or ‘Spectroscopy’.</dd>
<dt>Returns:</dt>
<dd><dl class="first last docutils">
<dt>Instance of <cite>ccdproc.CCDData</cite> corresponding to the file from</dt>
<dd><cite>full_path</cite>.</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="pipeline.core.core.save_extracted">
<code class="descclassname">pipeline.core.core.</code><code class="descname">save_extracted</code><span class="sig-paren">(</span><em>ccd</em>, <em>destination</em>, <em>prefix='e'</em><span class="sig-paren">)</span><a class="headerlink" href="#pipeline.core.core.save_extracted" title="Permalink to this definition">¶</a></dt>
<dd><p>Save extracted spectrum while adding a prefix.</p>
<dl class="docutils">
<dt>Args:</dt>
<dd>ccd (object): CCDData instance
destination (str): Path where the file will be saved.
prefix (str): Prefix to be added to images. Default <cite>e</cite>.</dd>
<dt>Returns:</dt>
<dd><cite>ccdproc.CCDData</cite> instance of the image just recorded. although is not
really necessary.</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="pipeline.core.core.search_comp_group">
<code class="descclassname">pipeline.core.core.</code><code class="descname">search_comp_group</code><span class="sig-paren">(</span><em>object_group</em>, <em>comp_groups</em>, <em>reference_data</em><span class="sig-paren">)</span><a class="headerlink" href="#pipeline.core.core.search_comp_group" title="Permalink to this definition">¶</a></dt>
<dd><p>Search for a suitable comparison lamp group</p>
<p>In case a science target was observed without comparison lamps, usually
right before or right after, this function will look for a compatible set
obtained at a different time or pointing.</p>
<dl class="docutils">
<dt>Notes:</dt>
<dd>This methodology is not recommended for radial velocity studies.</dd>
<dt>Args:</dt>
<dd><dl class="first last docutils">
<dt>object_group (object): A pandas.DataFrame instances containing a group</dt>
<dd>of images for a given scientific target.</dd>
<dt>comp_groups (list): A list in which every element is a pandas.DataFrame</dt>
<dd>that contains information regarding groups of comparison lamps.</dd>
<dt>reference_data (object): Instance of</dt>
<dd><cite>goodman.pipeline.core.ReferenceData</cite> contains all information
related to the reference lamp library.</dd>
</dl>
</dd>
</dl>
<p>Returns:</p>
</dd></dl>

<dl class="function">
<dt id="pipeline.core.core.setup_logging">
<code class="descclassname">pipeline.core.core.</code><code class="descname">setup_logging</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pipeline.core.core.setup_logging" title="Permalink to this definition">¶</a></dt>
<dd><p>configures logging</p>
<dl class="docutils">
<dt>Notes:</dt>
<dd>Logging file name is set to default ‘goodman_log.txt’.
If –debug is activated then the format of the message is different.</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="pipeline.core.core.trace">
<code class="descclassname">pipeline.core.core.</code><code class="descname">trace</code><span class="sig-paren">(</span><em>ccd</em>, <em>model</em>, <em>trace_model</em>, <em>model_fitter</em>, <em>sampling_step</em>, <em>nsigmas=2</em><span class="sig-paren">)</span><a class="headerlink" href="#pipeline.core.core.trace" title="Permalink to this definition">¶</a></dt>
<dd><p>Find the trace of a spectrum</p>
<p>This function is called by the <cite>trace_targets</cite> function, the difference is
that it only takes single models only not <cite>CompoundModels</cite> so this function
is called for every single target. <cite>CompoundModels</cite> are a bit tricky when
you need each model separated so all <cite>CompoundModels</cite> have been removed.</p>
<dl class="docutils">
<dt>Notes:</dt>
<dd>This method forces the trace to go withing a rectangular region of
center <cite>model.mean.value</cite> and width <cite>2 * nsigmas</cite>, this is for allowing
the tracing of low SNR targets. The assumption is valid since the
spectra are always well aligned to the detectors’s pixel columns.
(dispersion axis)</dd>
<dt>Args:</dt>
<dd>ccd (object): A ccdproc.CCDData instance, 2D image.
model (object): An astropy.modeling.Model instance that contains
information regarding the target to be traced.
trace_model (object): An astropy.modeling.Model instance, usually a low
order polynomial.
model_fitter (object): An astropy.modeling.fitting.Fitter instance. Will
fit the sampled points to construct the trace model
sampling_step (int): Step for sampling the spectrum.
nsigmas (int): Number of stddev to each side of the mean to be used for
searching the trace.</dd>
<dt>Returns:</dt>
<dd>An <cite>astropy.modeling.Model</cite> instance, that defines the trace of the
spectrum.</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="pipeline.core.core.trace_targets">
<code class="descclassname">pipeline.core.core.</code><code class="descname">trace_targets</code><span class="sig-paren">(</span><em>ccd</em>, <em>target_list</em>, <em>sampling_step=5</em>, <em>pol_deg=2</em>, <em>nsigmas=10</em>, <em>plots=False</em><span class="sig-paren">)</span><a class="headerlink" href="#pipeline.core.core.trace_targets" title="Permalink to this definition">¶</a></dt>
<dd><p>Find the trace of the target’s spectrum on the image</p>
<p>This function defines a low order polynomial that trace the location of the
spectrum. The attributes pol_deg and sampling_step define the polynomial
degree and the spacing in pixels for the samples. For every sample a
gaussian model is fitted and the center (mean) is recorded and since
spectrum traces vary smoothly this value is used as a new center for the
base model used to fit the spectrum profile.</p>
<dl class="docutils">
<dt>Notes:</dt>
<dd>This doesn’t work for extended sources. Also this calls for the function
<cite>trace</cite> for doing the actual trace, the difference is that this method
is at a higher level.</dd>
<dt>Args:</dt>
<dd>ccd (object): Instance of ccdproc.CCDData
target_list (list): List of single target profiles.
sampling_step (int): Frequency of sampling in pixels
pol_deg (int): Polynomial degree for fitting the trace
plots (bool): If True will show plots (debugging)
nsigmas (int): Number of sigmas to search for a target. default 10.</dd>
<dt>Returns:</dt>
<dd><dl class="first last docutils">
<dt>all_traces (list): List that contains traces that are</dt>
<dd>astropy.modeling.Model instance</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="pipeline.core.core.write_fits">
<code class="descclassname">pipeline.core.core.</code><code class="descname">write_fits</code><span class="sig-paren">(</span><em>ccd</em>, <em>full_path</em>, <em>combined=False</em>, <em>parent_file=None</em>, <em>overwrite=True</em><span class="sig-paren">)</span><a class="headerlink" href="#pipeline.core.core.write_fits" title="Permalink to this definition">¶</a></dt>
<dd><p>Write fits while adding information to the header.</p>
<p>This is a wrapper for allowing to save files while being able to add
information into the header. Mostly for historical reasons.</p>
<dl class="docutils">
<dt>Args:</dt>
<dd>ccd (object): <cite>ccdproc.CCDData</cite> instance to be saved to fits.
full_path (str): Full path of file.
combined (bool): True if <cite>ccd</cite> is the result of combining images.
parent_file (str): Name of the file from which ccd originated. If
combined is True this will be set to <cite>combined</cite>.
overwrite (bool): Overwrite files, default True.</dd>
<dt>Returns:</dt>
<dd><cite>ccdproc.CCDData</cite> instance.</dd>
</dl>
</dd></dl>

</div>
<div class="section" id="module-pipeline.core">
<span id="module-contents"></span><h2>Module contents<a class="headerlink" href="#module-pipeline.core" title="Permalink to this headline">¶</a></h2>
</div>
</div>


           </div>
           
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2017 NOAO/AURA, Inc. All rights reserved..

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'../',
            VERSION:'1.0.0',
            LANGUAGE:'None',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true,
            SOURCELINK_SUFFIX: '.txt'
        };
    </script>
      <script type="text/javascript" src="../_static/jquery.js"></script>
      <script type="text/javascript" src="../_static/underscore.js"></script>
      <script type="text/javascript" src="../_static/doctools.js"></script>

  

  
  
    <script type="text/javascript" src="../_static/js/theme.js"></script>
  

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>